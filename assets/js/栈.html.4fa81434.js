"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[906],{6262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,t]of s)a[n]=t;return a}},5620:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>p,data:()=>l});var t=a(641);const e=[(0,t.Fv)('<h1 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h1><p>栈（Stack）是一种只允许在一端进行插入或删除操作的线性表。这种结构具有后进先出（Last In First Out, LIFO）的特性，意味着最后插入的元素将是第一个被删除的。在栈中，插入和删除操作通常发生在同一端，称为栈顶，而另一端则被称为栈底。</p><p>栈的基本操作包括：</p><ul><li><strong>初始化</strong>（InitStack）：创建一个空栈。</li><li><strong>判空</strong>（Empty）：检查栈是否为空。</li><li><strong>进栈</strong>（Push）：在栈顶添加一个元素。</li><li><strong>出栈</strong>（Pop）：移除栈顶的元素。</li><li><strong>读栈顶元素</strong>（GetTop）：获取栈顶元素的值，但不移除它。</li><li><strong>销毁栈</strong>（DestroyStack）：移除栈中的所有元素，并释放内存。</li></ul><p>栈可以通过数组（顺序栈）或链表（链栈）来实现。顺序栈使用连续的内存空间存储元素，而链栈则通过链表的节点来存储，每个节点包含数据和指向下一个节点的指针。</p><h2 id="c-stl-之-stack" tabindex="-1"><a class="header-anchor" href="#c-stl-之-stack"><span>C++ STL 之 Stack</span></a></h2><p>头文件&lt;stack&gt;</p><p>常用操作</p><ol><li>push(x) 将x入栈</li><li>top() 返回栈顶元素</li><li>pop() 删除栈顶元素</li><li>size() 返回栈中元素个数</li><li>empty() 检查是否空栈</li></ol><h2 id="栈的应用" tabindex="-1"><a class="header-anchor" href="#栈的应用"><span>栈的应用</span></a></h2><h3 id="括号匹配问题" tabindex="-1"><a class="header-anchor" href="#括号匹配问题"><span>括号匹配问题</span></a></h3><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>#include &lt;stack&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n\nbool brace_match(std::string s) {\n    std::unordered_map&lt;char, char&gt; match = {{&#39;}&#39;, &#39;{&#39;}, {&#39;]&#39;, &#39;[&#39;}, {&#39;)&#39;, &#39;(&#39;}};\n    std::stack&lt;char&gt; st;\n    \n    for (char ch : s) {\n        if (ch == &#39;{&#39; || ch == &#39;[&#39; || ch == &#39;(&#39;) {\n            st.push(ch);\n        } else {\n            if (st.empty()) {\n                return false;\n            } else if (st.top() == match[ch]) {\n                st.pop();\n            } else {\n                return false;\n            }\n        }\n    }\n    \n    return st.empty();\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">brace_match</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">match</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&#39;}&#39;</span><span class="token punctuation">:</span><span class="token string">&#39;{&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;]&#39;</span><span class="token punctuation">:</span><span class="token string">&quot;[&quot;</span><span class="token punctuation">,</span> <span class="token string">&#39;)&#39;</span><span class="token punctuation">:</span><span class="token string">&#39;(&#39;</span><span class="token punctuation">}</span>\n    stack <span class="token operator">=</span> Stack<span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>\n        <span class="token keyword">if</span> ch <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token string">&#39;(&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;[&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;{&#39;</span><span class="token punctuation">}</span><span class="token punctuation">:</span>\n            stack<span class="token punctuation">.</span>push<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>\n        <span class="token keyword">else</span><span class="token punctuation">:</span>   <span class="token comment">#ch in {&#39;}&#39;,&#39;]&#39;,&#39;)&#39;}</span>\n            <span class="token keyword">if</span> stack<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>\n                <span class="token keyword">return</span> <span class="token boolean">False</span>\n            <span class="token keyword">elif</span> stack<span class="token punctuation">.</span>get_top<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">match</span><span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">:</span>\n                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>\n            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># stack.get_top() != match[ch]</span>\n                <span class="token keyword">return</span> <span class="token boolean">False</span>\n    <span class="token keyword">if</span> stack<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>\n        <span class="token keyword">return</span> <span class="token boolean">True</span>\n    <span class="token keyword">else</span><span class="token punctuation">:</span>\n        <span class="token keyword">return</span> <span class="token boolean">False</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h1>',14)],i={},p=(0,a(6262).A)(i,[["render",function(n,s){return(0,t.uX)(),(0,t.CE)("div",null,e)}]]),l=JSON.parse('{"path":"/datastruc/%E6%A0%88.html","title":"栈","lang":"zh-CN","frontmatter":{"category":"数据结构","description":"栈 栈（Stack）是一种只允许在一端进行插入或删除操作的线性表。这种结构具有后进先出（Last In First Out, LIFO）的特性，意味着最后插入的元素将是第一个被删除的。在栈中，插入和删除操作通常发生在同一端，称为栈顶，而另一端则被称为栈底。 栈的基本操作包括： 初始化（InitStack）：创建一个空栈。 判空（Empty）：检查栈是否...","head":[["meta",{"property":"og:url","content":"https://Misty-Star.github.io/datastruc/%E6%A0%88.html"}],["meta",{"property":"og:site_name","content":"MistyStar"}],["meta",{"property":"og:title","content":"栈"}],["meta",{"property":"og:description","content":"栈 栈（Stack）是一种只允许在一端进行插入或删除操作的线性表。这种结构具有后进先出（Last In First Out, LIFO）的特性，意味着最后插入的元素将是第一个被删除的。在栈中，插入和删除操作通常发生在同一端，称为栈顶，而另一端则被称为栈底。 栈的基本操作包括： 初始化（InitStack）：创建一个空栈。 判空（Empty）：检查栈是否..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-09T15:02:29.000Z"}],["meta",{"property":"article:author","content":"MistyStar"}],["meta",{"property":"article:modified_time","content":"2024-05-09T15:02:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"栈\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-09T15:02:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MistyStar\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"C++ STL 之 Stack","slug":"c-stl-之-stack","link":"#c-stl-之-stack","children":[]},{"level":2,"title":"栈的应用","slug":"栈的应用","link":"#栈的应用","children":[{"level":3,"title":"括号匹配问题","slug":"括号匹配问题","link":"#括号匹配问题","children":[]}]}],"git":{"createdTime":1715266949000,"updatedTime":1715266949000,"contributors":[{"name":"Misty-Star","email":"1278734874@qq.com","commits":1}]},"readingTime":{"minutes":1.35,"words":404},"filePathRelative":"datastruc/栈.md","localizedDate":"2024年5月9日","excerpt":"\\n<p>栈（Stack）是一种只允许在一端进行插入或删除操作的线性表。这种结构具有后进先出（Last In First Out, LIFO）的特性，意味着最后插入的元素将是第一个被删除的。在栈中，插入和删除操作通常发生在同一端，称为栈顶，而另一端则被称为栈底。</p>\\n<p>栈的基本操作包括：</p>\\n<ul>\\n<li><strong>初始化</strong>（InitStack）：创建一个空栈。</li>\\n<li><strong>判空</strong>（Empty）：检查栈是否为空。</li>\\n<li><strong>进栈</strong>（Push）：在栈顶添加一个元素。</li>\\n<li><strong>出栈</strong>（Pop）：移除栈顶的元素。</li>\\n<li><strong>读栈顶元素</strong>（GetTop）：获取栈顶元素的值，但不移除它。</li>\\n<li><strong>销毁栈</strong>（DestroyStack）：移除栈中的所有元素，并释放内存。</li>\\n</ul>","autoDesc":true}')}}]);